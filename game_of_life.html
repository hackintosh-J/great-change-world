<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Game of Life - Great Change World</title>
<style>
body { font-family: Arial, sans-serif; margin:0; padding:0; background-color:#f5f5f5; }
header { background-color:#333; padding:10px; }
header nav a { color:white; margin-right:15px; text-decoration:none; font-weight:bold; }
header nav a:hover { text-decoration:underline; }
#container { padding:20px; }
canvas { border:1px solid #ccc; background-color:#fff; }
button { margin:5px; padding:5px 10px; }
</style>
</head>
<body>
<header>
<nav>
<a href="index.html">Home</a>
<a href="fractal.html">Fractal Explorer</a>
<a href="game_of_life.html">Game of Life</a>
<a href="sir_simulator.html">Epidemic Simulator</a>
<a href="about.html">About</a>
</nav>
</header>
<div id="container">
<h1>Conway's Game of Life</h1>
<p>Click cells to toggle life. Use the controls to start, stop, randomize or clear the grid. This simulation shows how simple rules lead to complex behavior.</p>
<canvas id="lifeCanvas" width="600" height="400"></canvas><br/>
<button id="startBtn">Start</button>
<button id="stopBtn">Stop</button>
<button id="stepBtn">Step</button>
<button id="randomBtn">Random</button>
<button id="clearBtn">Clear</button>
</div>
<script>
const canvas = document.getElementById('lifeCanvas');
const ctx = canvas.getContext('2d');
const cols = 60;
const rows = 40;
const cellSize = canvas.width / cols;
let grid = createEmptyGrid();
let running = false;
let intervalId;
function createEmptyGrid() {
  const arr = [];
  for (let y=0; y<rows; y++) {
    arr[y] = [];
    for (let x=0; x<cols; x++) {
      arr[y][x] = 0;
    }
  }
  return arr;
}
function randomizeGrid() {
  for (let y=0; y<rows; y++) {
    for (let x=0; x<cols; x++) {
      grid[y][x] = Math.random() > 0.7 ? 1 : 0;
    }
  }
}
function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let y=0; y<rows; y++) {
    for (let x=0; x<cols; x++) {
      ctx.fillStyle = grid[y][x] ? '#000' : '#fff';
      ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
      ctx.strokeStyle = '#e0e0e0';
      ctx.strokeRect(x*cellSize, y*cellSize, cellSize, cellSize);
    }
  }
}
function getNeighborCount(y, x) {
  let count = 0;
  for (let i=-1; i<=1; i++) {
    for (let j=-1; j<=1; j++) {
      if (i===0 && j===0) continue;
      const ny = y + i;
      const nx = x + j;
      if (ny>=0 && ny<rows && nx>=0 && nx<cols) {
        count += grid[ny][nx];
      }
    }
  }
  return count;
}
function updateGrid() {
  const newGrid = createEmptyGrid();
  for (let y=0; y<rows; y++) {
    for (let x=0; x<cols; x++) {
      const neighbors = getNeighborCount(y, x);
      if (grid[y][x] === 1) {
        newGrid[y][x] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
      } else {
        newGrid[y][x] = neighbors === 3 ? 1 : 0;
      }
    }
  }
  grid = newGrid;
}
function step() {
  updateGrid();
  drawGrid();
}
canvas.addEventListener('click', function(event) {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((event.clientX - rect.left) / cellSize);
  const y = Math.floor((event.clientY - rect.top) / cellSize);
  grid[y][x] = grid[y][x] ? 0 : 1;
  drawGrid();
});
document.getElementById('startBtn').addEventListener('click', function() {
  if (!running) {
    running = true;
    intervalId = setInterval(step, 200);
  }
});
document.getElementById('stopBtn').addEventListener('click', function() {
  running = false;
  clearInterval(intervalId);
});
document.getElementById('stepBtn').addEventListener('click', function() {
  step();
});
document.getElementById('randomBtn').addEventListener('click', function() {
  randomizeGrid();
  drawGrid();
});
document.getElementById('clearBtn').addEventListener('click', function() {
  grid = createEmptyGrid();
  drawGrid();
});
// Initialize
drawGrid();
</script>
</body>
</html>
